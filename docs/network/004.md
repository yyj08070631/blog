# 004 HTTP 头部：缓存策略

::: tip 部分参考来源
[那些年与面试官交手过的 HTTP 问题](https://mp.weixin.qq.com/s/3xezNAr4yZa2LQURIarHZg)
[HTTP 条件请求](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Conditional_requests)
:::

通过网络提取内容既速度缓慢又开销巨大。 较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。 因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。

## 强缓存

强缓存是浏览器获取资源的第一层阻隔，它完全基于本地缓存的内容，如果命中了强缓存，则完全不会发送 HTTP 请求。

### Expires

HTTP/1.0 规范中约定使用 Expires 响应头传递一个来指定资源的到期时间。

```
Expires: Wed, 22 Nov 2019 08:41:00 GMT
```

但是这个方式有一个严重的问题，就是忽略了客户端和服务端的时间有可能不一样，这种情况下过期时间的判断就会不准确，因此在 HTTP/1.1 中这个方案已经弃用。

### Cache-Control

HTTP/1.1 中使用 Cache-Control 来控制资源的强缓存，常用的方式是通过 max-age 字段指定一个过期时长，单位为秒。

> 注意：这里的 max-age 的时间计算起点是响应报文的创建时刻，而不是客户端收到报文的时刻。

```
Cache-Control:max-age=3600
```

除了 max-age 之外，Cache-Control 常用的属性还有：

* no-store：不允许缓存 (用于秒杀页面等变化频率非常高的场景)
* no-cache：可以缓存，使用前必须要去服务端验证是否过期，是否是最新版本（强制跳过强缓存阶段，发请求到服务端验证协商缓存）
* must-revalidate：如果缓存不过期就可以继续使用，过期了就必须去服务端验证

另外，浏览器也可以主动发送 Cache-Control 字段，使用 max-age=0 或 no-cache 来刷新数据

## 协商缓存

协商缓存是浏览器获取资源的第二层阻隔，它的基本原理是：通过某些头字段，验证服务端资源是否产生了修改，若没有修改，则判定为命中协商缓存，返回 304 Not Modified 状态码。

### Last-Modified 与 If-Modified-Since

在请求一个资源时，服务器会在 Last-Modified 响应头中返回这个资源的最后修改时间，在浏览器下一次请求这个资源时，则会将这个时间由条件请求头 If-Modified-Since 传达给服务器，由服务器验证是否返回缓存内容。

```
# 响应
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
# 请求
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
```

### Etag 与 If-None-Match

Etag 的缓存方案比较特殊，它不是基于时间，而是对每一个资源生成一个版本标识符，在响应时交给浏览器，而浏览器在再次请求时则发送一个值为 Etag 的请求头字段 If-None-Match，由服务器验证 Etag 是否匹配，决定是否返回缓存内容。

```
# 响应
ETag: W/"<etag_value>"
ETag: "<etag_value>"
# 请求
```

根据上面的栗子，Etag 根据是否有 `W/` 开头分为两种类型：

没有 `W/` 的称为 **强验证类型（Strong validation）**，其作用在于确保要比较的资源与其相比较的对象之间每一个字节都相同。强验证类型的要求相当严格，在服务器层面来说可能较难保证。但是它确保了数据在任何时候都没有缺损，有时候则需要以牺牲性能为代价。

带有 `W/` 的称为 **弱验证类型（Weak validation）**，弱验证类型不保证资源的所有状态完全一致，它会根据资源属性的重要性进行排序，再决定要验证哪些部分是需要验证是否发生修改的。它一般只保证内容主体相同，允许部分片段有差异，但性能比强验证类型更好。

HTTP 协议默认使用强验证类型，可以指定何时使用弱验证类型。

HTTP 规范没有严格规定生成 Etag 需要采用的算法，但强验证类型通常采用 MD5 算法获取的资源（或其衍生品）的散列值进行标识，而构建弱验证类型 Etag 的体系可能会比较复杂，因为这会涉及到对页面上不同元素的重要性进行排序。

### Last-Modified 与 Etag

从 Last-Modified 的描述中我们注意到，max-age 属性设置的时间只能精确到秒，这是其局限所在，而 Etag 不基于时间的特性则可以很好的解决这个问题。
