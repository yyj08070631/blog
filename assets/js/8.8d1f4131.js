(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{258:function(t,s,a){t.exports=a.p+"assets/img/00020.90601448.png"},275:function(t,s,a){"use strict";a.r(s);var n=a(28),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"_004-模拟实现-new"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_004-模拟实现-new"}},[t._v("#")]),t._v(" 004 模拟实现 new")]),t._v(" "),n("h2",{attrs:{id:"实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),n("p",[t._v("根据 MDN 文档的描述，"),n("code",[t._v("new")]),t._v(" 关键字主要做了以下四点工作：")]),t._v(" "),n("ol",[n("li",[t._v("创建一个空的简单 JavaScript 对象（即 "),n("code",[t._v("{}")]),t._v("）；")]),t._v(" "),n("li",[t._v("链接该对象（即设置该对象的构造函数）到另一个对象；")]),t._v(" "),n("li",[t._v("将步骤 1 新创建的对象作为 "),n("code",[t._v("this")]),t._v(" 的上下文；")]),t._v(" "),n("li",[t._v("如果该函数没有返回对象，则返回 "),n("code",[t._v("this")]),t._v("。")])]),t._v(" "),n("p",[t._v("下面先拿冴羽大佬博客原文的代码来分析。")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("objectFactory")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对应 1：创建一个空对象")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" obj "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 第一个实参为构造函数，提取之")]),t._v("\n  Constructor "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("shift")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arguments"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对应 2：实例对象之所以能取到构造函数原型对象中的值")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 就是因为实例对象中有一个 __proto__ 属性，里面保存了构造函数的原型对象")]),t._v("\n  obj"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__proto__ "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Constructor")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对应 3：使用 new 创建实例对象时，构造函数中的 this 会指向新的实例对象")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这样实例对象就可以访问到构造函数中使用 this.xxx 定义的属性")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" ret "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("Constructor")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("apply")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("obj"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" arguments"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对应 4：如果构造函数有返回值，且返回值为对象，则返回构造函数的返回值")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 否则，返回生成的实例对象")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" ret "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'object'")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" ret "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" obj\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("h2",{attrs:{id:"争论"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#争论"}},[t._v("#")]),t._v(" 争论")]),t._v(" "),n("p",[t._v("在这篇博文下有不少争论的点，归纳如下：")]),t._v(" "),n("ol",[n("li",[t._v("第一步创建一个空对象中，有同学认为既然是在模拟 "),n("code",[t._v("new")]),t._v("，那么在函数内部还使用 "),n("code",[t._v("new")]),t._v(" 去创建一个新对象貌似不太合理，那么这一步的功能就衍生了几种做法：")])]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 创建一个新的空对象")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" obj "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// √")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" obj "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Object"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// √")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" obj "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Object"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Constructor")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// √")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" obj "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Object"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ×")]),t._v("\n")])])]),n("p",[t._v("其中前三种方式，模拟函数都是能正常运行的，甚至直接使用构造函数的 "),n("code",[t._v("prototype")]),t._v(" 来创建对象，也能获取正确的结果，但 "),n("code",[t._v("var obj = Object.create(null)")]),t._v(" 则会导致 "),n("code",[t._v("prototype")]),t._v(" 中定义的东西全部都无法获取。这个问题博主在其中一条回复中做过解释：")]),t._v(" "),n("blockquote",[n("p",[t._v("如果使用 Object.create(null)，person.sayHello 就会报错，使用 new Object()，会正常打印 hello。"),n("br"),t._v("\n查看由两种方式生成的 person 对象，第一个是由 Object.create 生成的，第二个是 new Object 生成的"),n("br"),t._v(" "),n("img",{attrs:{src:a(258),alt:""}}),n("br"),t._v("\n两者的区别就在于 __proto__ 一个是实的，一个是虚的，由此我们可以猜测第一种方式是把 __proto__ 当成了一个属性值，而非去修改了原型！"),n("br"),t._v("\n原因其实在 《JavaScript深入之从原型到原型链》中有提过："),n("br"),t._v("\n__proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。")])]),t._v(" "),n("ol",[n("li",[t._v("第四点中 "),n("code",[t._v("typeof ret === 'object'")]),t._v(" 无法覆盖所有会返回构造函数返回值的情况，比如返回的如果是数组、函数，在 "),n("code",[t._v("new")]),t._v(" 中也会返回构造函数返回值，同样列举评论中见到的几种判断是否返回构造函数返回值的方法：")])]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 判断是否返回构造函数的返回值")]),t._v("\n\n")])])]),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[t._v("部分参考来源")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/mqyqingfeng/Blog/issues/13",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript 深入之 new 的模拟实现"),n("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=e.exports}}]);