(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{264:function(e,t,r){e.exports=r.p+"assets/img/00017.0c845226.jpg"},265:function(e,t,r){e.exports=r.p+"assets/img/00018.ac1ab9de.jpg"},283:function(e,t,r){"use strict";r.r(t);var s=r(28),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"_008-tls-握手协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_008-tls-握手协议"}},[e._v("#")]),e._v(" 008 TLS 握手协议")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Keyless SSL: The Nitty Gritty Technical Details"),s("OutboundLink")],1),e._v(" 是 Cloudflare 发布 Keyless SSL 服务（即无需私钥的 HTTPS CDN 托管服务）的说明文档，它使用丰富的插图以及有条理的行文结构解释了 TLS 握手的过程。阮一峰老师也根据这篇文章编写了 "),s("a",{attrs:{href:"https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("图解SSL/TLS协议"),s("OutboundLink")],1),e._v(" 一文。")]),e._v(" "),s("p",[e._v("本文将在这篇文章的基础上，结合一些其他的参考资料，整理关于 TLS 握手过程的描述。")]),e._v(" "),s("h2",{attrs:{id:"概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),s("p",[e._v("TLS 握手一般分为 RSA 握手与 DH 握手，这两种握手的区别在于采用的加密套件（Cipher suite）的不同，这些概念将会在后面一一解释。")]),e._v(" "),s("h2",{attrs:{id:"rsa-握手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rsa-握手"}},[e._v("#")]),e._v(" RSA 握手")]),e._v(" "),s("p",[s("img",{attrs:{src:r(264),alt:"RSA 握手过程"}})]),e._v(" "),s("blockquote",[s("p",[e._v("图：RSA 握手过程")])]),e._v(" "),s("h3",{attrs:{id:"概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[e._v("#")]),e._v(" 概念")]),e._v(" "),s("p",[e._v("首先解释一下图中这些陌生的概念：")]),e._v(" "),s("ol",[s("li",[s("strong",[e._v("加密套件（Cipher suite）")]),e._v("：这是一个由一组加密算法的名称组成的唯一标识符，在上图第 1 步中，用于客户端向服务端询问 TLS 通信采用的加密方案。以一个 RSA 握手的 Cipher suite 为例：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("TLS_RSA_WITH_AES_128_GCM_SHA256\n")])])]),s("p",[e._v("Cipher suite 的结构一般由四个算法组成：")]),e._v(" "),s("ul",[s("li",[e._v("一个密钥交换（Key Exchange）算法，一般是一个非对称加密算法，用于图中客户端使用公钥加密预主密钥（Premaster secret），服务端使用私钥解密的过程。在例子中就是 RSA，表示采用的是 RSA 算法")]),e._v(" "),s("li",[e._v("一个认证（Authentication）算法，一般是一个非对称加密算法，在例子中仍是 RSA（在 RSA 握手中，密钥交换与身份认证使用同一组密钥，它们都是由 RSA 算法生成，只有在 DH 握手中才会使用两种不同的加密算法生成两组密钥去分别做这两件事，“一对密钥只做一件事情”能够保证协议的"),s("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%89%8D%E5%90%91%E4%BF%9D%E5%AF%86",target:"_blank",rel:"noopener noreferrer"}},[e._v("前向安全性（Perfect forward secrecy）"),s("OutboundLink")],1),e._v("。更详细的内容会在 DH 握手的章节中进一步说明）")]),e._v(" "),s("li",[e._v("一个加密（Encryption）算法，一般是一个对称加密算法，以握手生成的 Session key 为公钥，加密来自应用层的消息体。在例子中是 AES_128_GCM，表示采用基于 "),s("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F#%E4%BC%BD%E7%BE%85%E7%93%A6/%E8%A8%88%E6%95%B8%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88GCM%EF%BC%89",target:"_blank",rel:"noopener noreferrer"}},[e._v("GCM 分组"),s("OutboundLink")],1),e._v(" 的 128 位 AES 加密")]),e._v(" "),s("li",[e._v("一个消息认证码（Message authentication code，缩写为 MAC）算法，一般是一个散列（Hash）函数，所以通常又称为 HMAC，用于对内容进行数字签名（digital signature）即验证消息完整性，以及进行对端的身份验证。在例子中为 SHA256，表示采用 256 位的 SHA 算法。")])]),e._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[s("p",[s("strong",[e._v("客户端随机数（Client random）")]),e._v("：这是一个由客户端生成的 32 字节序列，在每次连接中都是唯一的，一般应该以 4 位的时间戳 + 28 位的随机字节组成，这类随机数一般叫做 "),s("a",{attrs:{href:"http://en.wikipedia.org/wiki/Cryptographic_nonce",target:"_blank",rel:"noopener noreferrer"}},[e._v("nonce"),s("OutboundLink")],1)])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("服务端随机数（Server random）")]),e._v("：与客户端随机数相同，唯一的区别就是，它是由服务端生成的")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("预主密钥（Pre-master secret）")]),e._v("：这是一个 48 字节的 blob 数据，一般是结合客户端随机数与服务端随机数，使用伪随机函数（Pseudorandom Function）生成的")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("会话密钥（Session key）")]),e._v("：这是 TLS 握手的最终目的，在握手的最后，客户端与服务端都能够拥有这个 Session key，因此可以将其作为对称加密的密钥，对双方的信息进行加解密")])])]),e._v(" "),s("h3",{attrs:{id:"过程梳理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#过程梳理"}},[e._v("#")]),e._v(" 过程梳理")]),e._v(" "),s("p",[e._v("解释完概念，下面来梳理一下握手的具体过程：")]),e._v(" "),s("ol",[s("li",[s("strong",[e._v("Client Hello")]),e._v("：客户端发送一条 Hello 信息发起握手，消息包含客户端要使用的 TLS 协议版本、Client random、Cipher suite、以及一些其他的必要信息")]),e._v(" "),s("li",[s("strong",[e._v("Server Hello")]),e._v("：服务端收到客户端的 Hello 信息，根据信息中提供的加密套件列表，决定最终的握手类型。最后返回给客户端一条 Server Hello 消息，消息包含服务端随机数、最终确定使用的加密套件列表、以及服务端的证书（如 HTTPS 证书，证书中包含 RSA 生成的公钥和服务器的域名）")]),e._v(" "),s("li",[s("strong",[e._v("客户端验证证书，生成预主密钥")]),e._v("：Server Hello 送来的证书经验证证书可信且站点归属正确后，客户端会将 Client random 与 Server random 结合，使用伪随机函数（Pseudorandom Function）生成 Pre-master secret，并使用证书中的公钥加密预主密钥，将其发送到服务端")]),e._v(" "),s("li",[s("strong",[e._v("服务端使用私钥解密，获取预主密钥")]),e._v("：服务端接收到加密后的 Pre-master secret，使用之前 RSA 生成的与公钥配对的私钥进行解密，获得与客户端相同的 Pre-master secret")]),e._v(" "),s("li",[s("strong",[e._v("生成 Session key")]),e._v("：此时客户端与服务端都通过密钥交换的过程，得到了相同的 Client random、Server random 与 Pre-master secret，客户端与服务端便可以各自推导出相同的 Session key，后续的通信内容则会使用这个 Session key 作为 AES_128_GCM 的密钥进行加解密")]),e._v(" "),s("li",[s("strong",[e._v("客户端与服务端交换加密的握手结束消息，并进行 HMAC 验证")]),e._v("：生成会话密钥（Session key）之后，客户端与服务端会使用 Session key 加密消息体，交换一次 Finish 消息，表示握手正式完成，确认双方都能正常的使用 Session key 进行加密的数据传输，同时在 Finish 消息中使用 HMAC 进行数字签名验证以验证握手阶段的完整性")])]),e._v(" "),s("p",[e._v("在这个过程中，如果发生了任何错误（如：服务端证书验证失败、完整性校验错误），则会发送一个 Alert 报文，转交给 Alert 协议层进行错误处理。")]),e._v(" "),s("h2",{attrs:{id:"dh-握手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dh-握手"}},[e._v("#")]),e._v(" DH 握手")]),e._v(" "),s("p",[s("img",{attrs:{src:r(265),alt:"DH 握手过程"}})]),e._v(" "),s("blockquote",[s("p",[e._v("图：DH 握手过程")])]),e._v(" "),s("h3",{attrs:{id:"与-rsa-握手的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#与-rsa-握手的区别"}},[e._v("#")]),e._v(" 与 RSA 握手的区别")]),e._v(" "),s("p",[e._v("如上一章所述，RSA 握手在密钥交换 + 身份认证的过程中使用了 RSA 生成的同一组密钥，这会带来前向安全性的问题，简单来说就是服务器私钥泄露带来的风险。在正常的通信中，客户端通过服务端给的公钥进行加密，而服务端则可以通过私钥解密客户端的信息，而问题在于，服务端的公钥是包含在服务端的证书内的，服务端的证书有效期通常会有数年之长，这意味着服务端的私钥如果泄露，那么在之前使用这个公钥加密的所有消息，全都可以被解密出来。")]),e._v(" "),s("p",[e._v("在上图描述的 DH 握手过程中，2a、2b 表示数字签名过程（与 RSA 中的相同），3、4 则是表示基于 DH 算法的密钥交换过程。")]),e._v(" "),s("blockquote",[s("p",[e._v("TLS 中一般采用的 DH 算法都是其变种："),s("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E6%A9%A2%E5%9C%93%E6%9B%B2%E7%B7%9A%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E9%87%91%E9%91%B0%E4%BA%A4%E6%8F%9B",target:"_blank",rel:"noopener noreferrer"}},[e._v("基于椭圆曲线的迪菲-赫尔曼密钥交换（Elliptic Curve Diffie–Hellman key exchange）"),s("OutboundLink")],1),e._v("，因此后文将统一以其简称 ECDHE 称呼密钥交换过程所依赖的算法。")])]),e._v(" "),s("p",[e._v("DH 握手中增加了基于 ECDHE 的密钥交换过程，该过程交换了一组"),s("strong",[e._v("由随机数生成的 DH 参数")]),e._v("，最终基于客户端 DH 参数与服务端 DH 参数，双端使用相同的 ECDHE 算法计算出 Premaster Secret，这一步非常重要，由于在每一次握手中增加了一组具有随机性质的参数，使得攻击者即使获取了这一次握手使用的所有私钥，也只能解密这一次通信的内容，而对于之前的所有通信无能为力，因为每一次通信的私钥都是不一样的，这为协议的通信赋予了前向安全性。最终 Premaster Secret 会结合之前数字签名过程生成的 Client random 和 Server random，生成最终用于通信加密的对称密钥 Session key。")]),e._v(" "),s("h3",{attrs:{id:"过程梳理-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#过程梳理-2"}},[e._v("#")]),e._v(" 过程梳理")]),e._v(" "),s("p",[e._v("基于上述对 DH 握手与 RSA 握手区别的描述，整理 DH 握手的过程，以下面的 Cipher suite 为例：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\n")])])]),s("ol",[s("li",[s("strong",[e._v("Client Hello")]),e._v("：客户端发送一条 Hello 信息发起握手，消息包含客户端要使用的 TLS 协议版本、Client random、Cipher suite、以及一些其他的必要信息")]),e._v(" "),s("li",[s("strong",[e._v("Server Hello")]),e._v("：服务端返回最终使用的 Cipher suite，服务端随机数以及包含 RSA 公钥的证书；并使用 RSA 的私钥对之前的所有报文（Client random、Server random 以及公钥证书）进行签名，发送到客户端；另外还会返回一个具有随机性质的，用于 ECDHE 密钥交换的 DH 参数")]),e._v(" "),s("li",[s("strong",[e._v("Client 验签，发送 Client DH Parameter，获得 Session key")]),e._v("：客户端使用公钥对服务端发来的数字签名进行验证，验证通过后，生成具有随机性质的 DH 参数，发送给服务端。此时，客户端已经拥有 Client DH Parameter 和 Server DH Parameter，可以通过 ECDHE 算法生成 Premaster Secret。此时客户端已经拥有了 Client random、Server random 和 Premaster Secret，便可以根据这三个参数推导出最终的 Session key")]),e._v(" "),s("li",[s("strong",[e._v("Server 接收 Client DH Parameter，获得 Session key")]),e._v("：服务端接收到客户端发来的 Client DH Parameter，也可以推导出最终的 Session key")]),e._v(" "),s("li",[s("strong",[e._v("客户端与服务端交换加密的握手结束消息，并进行 HMAC 验证")]),e._v("：生成 Session key 之后，客户端与服务端会使用 Session key 加密消息体，交换一次 Finish 消息，表示握手正式完成，确认双方都能正常的使用 Session key 进行加密的数据传输，同时在 Finish 消息中使用 HMAC 进行数字签名验证以验证握手阶段的完整性")])]),e._v(" "),s("p",[s("a",{attrs:{href:"https://tls.ulfheim.net/",target:"_blank",rel:"noopener noreferrer"}},[e._v("The Illustrated TLS Connection"),s("OutboundLink")],1),e._v(" 这是一个 TLS 1.2 DH 握手的实现，它的官网非常具体的介绍了 DH 握手过程中的细节，细致到每一份报文的结构，以及每一个计算步骤的详细过程，是非常好的扩展阅读材料。在这个实现中，根据 Client random、Server random 和 Premaster Secret 推导 Session key 的过程是基于 HMAC 的一组算法。")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("部分参考来源")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://blog.helong.info/post/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/",target:"_blank",rel:"noopener noreferrer"}},[e._v("TLS 协议分析 与 现代加密通信协议设计"),s("OutboundLink")],1)]),e._v(" "),s("p",[s("a",{attrs:{href:"https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Keyless SSL: The Nitty Gritty Technical Details"),s("OutboundLink")],1)]),e._v(" "),s("p",[s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/28850798",target:"_blank",rel:"noopener noreferrer"}},[e._v("TLS 1.3科普——新特性与协议实现"),s("OutboundLink")],1)]),e._v(" "),s("p",[s("a",{attrs:{href:"https://tls.ulfheim.net/",target:"_blank",rel:"noopener noreferrer"}},[e._v("The Illustrated TLS Connection"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=a.exports}}]);