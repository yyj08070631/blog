### 1. 判断iOS中是用WebView还是Safari访问站点

### 2. node-sass在外网安装后发到内网使用无法编译
根据报错显示，node-sass需要使用node 8.x版本才能正常编译，而内网机使用的是6.x。

### 3. 在vue的template中获取节点的样式（高度）
```html
<div ref="div">{{ $refs.div.outerHTML }}</div>
```
最终还是选择绕过。。。问题的原因是在template渲染的时候DOM还没完全渲染好，无法马上获取DOM节点数据。解决方案是在mounted中遍历$refs获取到的节点集获取每个节点的高度，插入到数据list的新属性height。

### 4. 局部拖动在ios safari中难以正确操作，极易误触发整个页面的拖动弹簧床效果
`viewport-fit=cover`
无视ios11自带的安全区域，将网站视窗扩展到全屏（一般用于对ipx刘海的适配）。
```html
<ul>
  <button>collapse</button>
  <li>内容内容内容</li>
</ul>
```
一个类似上面代码的结构，将高度控制从ul上改到li上，解决问题，所以最终原理不明。。。

### 5. ie9路由跳转路径有变化
跳转时使用了路由拼接，使用了window.location.origin属性获取域名，而这个属性在低版本ie（ie9）中没有，导致拼接的url结果有误，因此使用window.location.host代替。

### 6. vue1中v-for多层级对象/数组报错
```javascript
{
  '内容': {
    '属性11': 11,
    '属性12': [
      {
        '属性21': 11,
        '属性22': 22,
        '属性23': [
          { '属性31': 111, '属性32': '123123' },
          { '属性31': 111, '属性32': '123123' }
        ]
      }
    ]
  }
}
```
遍历到第二层级时报item['属性12']的TypeError，cannot read property ['属性12'] of undefined.
解决：仍然是老生常谈的加载顺序问题，但直接在v-for挂载的元素上使用v-if仍不生效，最终选择在外部包裹一个template，在template上使用v-if，解决。
```html
<!-- <td v-if="item" v-for="..."></td> -->
<template v-if="item">
  <td v-for="..."></td>
</template>
```

### 7. 在对象上添加新属性，且当对象中原有此属性也不进行覆盖
你觉得有可能吗

### 8. vue1的`this.$delete`只能特么的删除实例上挂载的对象，那么我想删除实例对象上的某个属性并更新dom怎么办呢
解决：黑科技
```javascript
delete this.obj.key
this.obj = JSON.parse(JSON.stringify(this.obj))
```
`this.obj`中存储的内存地址改变了，因此触发了data的响应式更新

### 9. 使用JSBridge与Native APP进行数据交互

### 10. vue-cli的项目中判断是生产环境还是开发环境
```javascript
process.env.NODE_ENV === 'development' // 开发
process.env.NODE_ENV === 'production' // 生产
```

### 11. 通过路由match配置面包屑导航方案

### 12. Vue中deep watch对象时新旧值一样的问题
由于新旧值都指向同一个引用，因此在handler中新旧值始终一样，若需区分对象的新旧值，可以通过开放一个computed属性，返回所要观察对象的深复制结果。
> 延伸：由于对象内都是简单的数据类型，且不愿引入新的库，因此采用简单的原生方法进行复制，试用了Object.assign()与JSON.parse(JSON.stringify())发现Object.assign()并不能比对我所需要的值，查阅MDN发现Object.assign()的说明：`针对深拷贝，需要使用其他方法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。`。因此最终选用JSON.parse(JSON.stringify())进行深拷贝

### 13. 子组件获取父组件实例，父组件获取子组件实例
1. 子组件获取父组件实例
```javascript
this.$parent // 直接在子组件中使用this.$parent即可获取父组件实例
```
2. 父组件获取子组件实例
```vue
<template>
  <div>
    <child ref="child"></child>
  </div>
</template>
<script>
export default {
  mounted () {
    console.log(this.$refs.child) // 获取对应子组件实例，也可以在父组件中使用this.$children获取子组件实例列表
  }
}
</script>
```

### 14.vue-cli proxyTable 对某个接口下所有的api做代理
```javascript
import axios from 'axios'
axios.default.baseURL = process.env.NODE_ENV === 'development' ? '/api' : ''
```
> axios中配置基础路径。这里的基础路径是代理中配置的路径，若环境为开发，则始终使用代理

```javascript
{
  dev: {
    proxyTable: {
      '/api': {
        target: 'http://www.xx.com',
        changeOrigin: true,
        pathRewrite: { '^/api': '' }
      }
    }
  }
}
```

> 这段代码的意思是，将http://www.xx.com 代理到/api；启用跨域；在真正发送请求时，把请求路径中的'/api'删去。

> 用代理, 首先你得有一个标识, 告诉他你这个连接要用代理. 不然的话, 可能你的 html, css, js这些静态资源都跑去代理. 所以我们只要接口用代理, 静态文件用本地.
'/api': {}, 就是告诉node, 我接口只要是'/api'开头的才用代理.所以你的接口就要这么写 /api/xx/xx. 最后代理的路径就是 http://www.xx.com/api/xx/xx.
可是不对啊, 我正确的接口路径里面没有/api啊. 所以就需要 pathRewrite,用''^/api'':'', 把'/api'去掉, 这样既能有正确标识, 又能在请求接口的时候去掉api.

### 15. vue中使用jsx
> 需要动态添加dom结构时使用jsx比使用字符串模板更方便（涵待开发新用途）

### 16. vue全局注册工具管理方案
> 在开发vue项目的过程中时常会遇到有些工具（methods，filter等等）在多个组件中都需要使用的情况，在每个组件中引入又太麻烦，因此一般会将这些方法全局引入。

* main.js
```javascript
import globalRegister from './utils/globalRegister.js'
Vue.use(globalRegister)
```

* globalRegister.js
```javascript
import * as methods from './globalRegister/methods.js'
import * as filter from './globalRegister/filter.js'

let globalRegister = {
  install () {
    for (let key in filter) { Vue.filter(key, filter) } // filter
    for (let key in methods) { Vue.prototype[key] = methods[key] }
  }
}
export default globalRegister
```

* methods.js
```javascript
export function confirm () {
  // ...
}
```

* filter.js
```javascript
export function date () {
  // return ...
}
```

### 17. $confirm组件二次封装总结

### 18. 让元素滚动到视图中
浏览器提供原生的方法支持，能兼容到ie8
```javascript
Element.scrollIntoView()
```
该方法支持直接调用，也可以传入配置对象，如：
```javascript
{
    behavior: "auto"  | "instant" | "smooth",
    block:    "start" | "end",
}
```
但传入配置对象的调用方法不兼容ie（只有直接调用`Element.scrollIntoView()`能支持）

### 19. 迁移到新的发布方案或开发模式时一定要为每个需求多留一些时间，由于发布卡住的时间一定要预留进去，否则完全自己吃亏

### 20. 获取浏览器scrollTop属性兼容问题

- IE6/7/8：
对于没有`doctype`声明的页面里可以使用`document.body.scrollTop`来获取`scrollTop`高度
对于有`doctype`声明的页面则可以使用`document.documentElement.scrollTop`
- Safari:
`safari`比较特别，有自己获取`scrollTop`的函数：`window.pageYOffset`
- Firefox:
火狐等等相对标准些的浏览器就省心多了，直接用`document.documentElement.scrollTop`

完美的获取`scrollTop`赋值短语
```javascript
var scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop
```

### 21. svn合并出错问题

### 22. 支持换行问题，css解决

```css
/* 可解析js换行符\n将其转换为换行显示，并忽略其他特殊标识 */
.element {
  white-space: pre-line;
}
```

### 23. vue1.x坑

1. vue2.x使用$emit传参时，在父组件中监听时可以通过`<child @on-xx="handler(arguments, 0)"></child>`获取参数列表或者`<child @on-xx="handler($event, 0)"></child>`获取单个参数

> 替代方案：vue1.x中接收参数的方式不同，`<child @on-xx="handler(0, $arguments)"></child>`。

2. vue1.x的$delete、$set相比vue2.x都没有正确的实现

> 替代方案：在对数组或对象进行增删项之后手动触发监视器的响应

```javascript
delete this.obj.key
this.obj = JSON.parse(JSON.stringify(this.obj))
```
