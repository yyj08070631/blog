# 工具

## jQuery与Vue的开发体验

使用`jQuery`的开发十分灵活，因为它可以操作一切的`DOM`元素，可以在任何地方对任何元素进行修改。但也正是由于这样的特点，导致数据流不易把控；每次都进行`DOM`的查找与修改，就算是开发人员自己，在重新看这些代码的时候，也会十分懵逼，不知道一堆DOM操作做了些什么；更要命的问题是数据层与视图层的同步问题，一般实现一个列表需要保存一份列表到内存，再构建列表的`DOM`渲染到页面上，如果中途需要对列表进行一定的操作，比如插入新列表项，就非常容易出现插入了`DOM`结构没有更新列表，或是更新列表的方式错误，导致页面结构与数据不同步，下次再对列表进行操作时，就会出现非常明显的bug，这种bug表现不明显，不易排查（因此诞生了大量的html模板引擎，就是为了实现数据与视图的同步）。所以写这种代码对程序员的素养要求非常高，不仅要在所有关键位置有易于理解的注释，还要有条理的规划代码结构、以及统一的代码风格，才能够使项目具有较高的可维护性。

# 视频

## 手动全屏实现

H5的`video`元素没有原生的全屏方法，只能通过调用浏览器的全屏方法，再将`video`元素`position: fixed`到全屏：
```javascript
// 浏览器全屏方法
function launchFullScreen (elem) {
  if (elem.requestFullscreen) {
    elem.requestFullscreen()
  } else if (elem.mozRequestFullscreen) {
    elem.mozRequestFullscreen()
  } else if (elem.webkitRequestFullscreen) {
    elem.webkitRequestFullscreen()
  } else if (elem.msRequestFullscreen) {
    elem.msRequestFullscreen()
  }
}
```

## 视频进度条、音量控制

使用了`jquery-ui`的`slider`小工具，该插件提供了回调方法接收滑动结束后的时间点进行操作，非常方便：
```javascript
$('#volumebar').slider({
  range: 'min',
  min: 1,
  max: 100,
  slide: function (e, ui) { videoElem.volume = ui.value / 100 }
})
```
上面的代码表示初始化了一个滑动条，范围为`1-100`，当拖动结束时，获取当前滑动到的点，赋给视频元素的`volume`属性，即可成功改变视频的声音。

视频进度条同理，但需注意，这里需要获取视频的总长度，因此需要监听视频的`onloadedmetadata`事件，必须获取了视频的元信息（包括视频长度等），才能声明滑动条：
```javascript
videoElem.onloadedmetadata = function () {
  $('#progressbar').slider({
    range: 'min',
    min: 0,
    max: videoElem.duration,
    slide: function (e, ui) { videoElem.currentTime = ui.value }
  })
}
```

## 视频加载报HTTP 206

206状态码是一种专用与分段传输的状态码，常见于视频、图片等大体积的资源，该响应会返回一个`Content-Range`响应头表明返回的是文件的哪一部分。该请求会多次发送，直到资源请求完毕为止。该请求只在zm1.0客户端内嵌浏览器（内核与chrome47相同）存在无法请求完所有资源的问题，其余浏览器均无问题（包括原版的chrome47）。

# 文字

## 原生WebSocket实现

使用浏览器原生的`WebSocket`对象创建`WebSocket`连接

```javascript
var wsImpl = window.WebSocket || window.MozWebSocket
var ws = new wsImpl('ws://xxx:8181/')
// onopen：在ws连通时触发
ws.onopen = function () { console.log('ws open.') }
// onclose：在ws关闭时触发，一般在这里做断线重连
ws.onopen = function () { console.log('ws close, reconnect it') }
// onmessage：在ws接收到消息推送时触发
ws.onmessage = function () { console.log('ws receive message.') }
// send：推送信息到服务端（推送消息一般进行加密，不能裸奔，这次采用了对称加密，因为担心对每条消息进行非对称的加解密会消耗大量性能）
ws.send('send a message.')
```
